private static void parseNode(JsonNode node, String currentPath,
                              List<Map<String, String>> allResults,
                              Map<String, String> currentMap) {

    if (node == null || node.isMissingNode()) return;

    if (node.isObject()) {
        node.fields().forEachRemaining(entry -> {
            String key = entry.getKey();
            JsonNode child = entry.getValue();
            String newPath = currentPath.isEmpty() ? key : currentPath + ":" + key;

            // If key looks like a segment, grab its elements directly
            if (key.toLowerCase().startsWith("segment-") && child.isObject()) {
                child.fields().forEachRemaining(element -> {
                    String elementPath = newPath + ":" + element.getKey();
                    currentMap.put(elementPath, element.getValue().asText());
                });
            }

            // Recurse into child regardless â€” in case deeper nesting exists
            parseNode(child, newPath, allResults, currentMap);
        });
    } else if (node.isArray()) {
        for (int i = 0; i < node.size(); i++) {
            JsonNode arrayNode = node.get(i);
            Map<String, String> newMap = new LinkedHashMap<>();
            parseNode(arrayNode, currentPath + "[" + i + "]", allResults, newMap);
            allResults.add(newMap);
        }
    } else if (node.isValueNode()) {
        currentMap.put(currentPath, node.asText());
    }
}
